Next.js Instagram Clone Project Analysis
How the Framework Works (Next.js App Router Flow)
The Next.js App Router framework works through the following flow:

Initial Request Processing:

When a client makes a request, it first hits the middleware.ts which checks authentication status and redirects if needed
The middleware uses verifySession to verify user authentication
Route Resolution:

Next.js resolves the route based on the directory structure in the app folder
Each folder represents a route segment, with special files like page.tsx defining the UI
Component Rendering:

Server components (default in App Router) render on the server first
For example, the home page/page.tsx) fetches initial data server-side
Client components (marked with 'use client') handle interactive elements
The rendering tree combines both server and client components
Data Fetching:

Server actions in actions folder handle data fetching
Initial data is loaded server-side for SEO and performance
Additional data is loaded through client-side interaction (e.g., infinite scroll in infinite-feed.tsx)
Response Generation:

The server generates HTML with data already included
Client-side JavaScript hydrates the page to make it interactive
The response is sent back to the client as HTML + JS
Authentication/Authorization Process
The authentication system uses a custom JWT (JSON Web Token) implementation:


Login/Registration:

Users register via RegisterForm component
Users log in via LoginForm component
Form submissions are handled by server actions in auth.ts
Password hashing is managed with bcrypt
Session Management:

JWT tokens are created in createSession function
Session data includes userId, username, expiration time, and role
Tokens are stored in HTTP-only cookies via Next.js cookies() API
Session data structure is defined in definitions.ts
Session Verification:

verifySession validates authenticity of the token
Protected routes check authentication status before rendering
User data can be accessed anywhere server-side via verifySession()
Authorization:

Role-based access control is implemented in middleware.ts
Admin routes (like /admin) are protected based on user role
User-specific routes verify the user's identity
ORM and Data Modeling
This project uses Drizzle ORM for database operations:


Schema Definition:

Database schema is defined in db/schema.ts (referenced in imports)
Tables like users, posts, comments, and likes are defined with relationships
For example, posts table is referenced in upload route
Data Operations:

CRUD operations use Drizzle's query builder syntax
Example: Post fetching in feed actions
Queries use functions like select(), where(), join(), etc.
Data Access Patterns:

Field values are accessed through defined schema columns
Example: posts.id, users.username in queries
Data relationships are managed through joins
Example: Posts and likes relationship in getPost function
Data Mutations:

Forms submit data via server actions
Example: Upload process in upload page
Data is validated (e.g., with Zod schemas) before database operations
State is updated client-side after successful operations
The application follows a consistent pattern of defining schemas with Drizzle, using server actions for data operations, and passing data between server and client components while keeping sensitive operations server-side.
